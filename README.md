# Прототип степпера для CCL. 

## Как установить и использовать 

Включён в текущую версию Яра. 

- Скачиваем релиз ccl 1.11 в c:\yar\ccl\tek

- Редактируем c:\yar\ccl\tek\.git\config так:
```
[remote "origin"]
	url = https://github.com/budden/ccl.git
```

- git pull
- git checkout stepper-2019 

- собираем согласно комментарию в https://budden73.livejournal.com/28995.html
(или инструкция для сборки - в lisp-kernel/win64/makefile)

- запускаем clcon на ccl (не забыть очистить кеш фаслов)

- выполняем hack-debugger-ccl.lisp

- `(in-package :NATIVE-CODE-STEPPER)`

- `(! 'ncse:fact 2)` - должен появиться отладчик с перезапуском "STEP-INTO"

## Особенности

Мы не можем (не умеем) сделать "step out". Поскольку в лиспе это можно сделать только через unwind-protect, а его нужно вставлять до запуска функции. Поэтому, если мы остановились по (break), перешли в режим ходьбы и пытаемся сделать «step out», то оно не сработает. 

Поэтому у нас step-over устанавливает точку остнова после возврата из функции, которая сработает, даже если пользователь в той ф-ии выбрал "continue". И только в этом случае мы можем узнать возврат из функции. 

Step-into позволяет зайти в функцию, но не позволяет увидеть её результат. 

Теперь мы знаем, что если мы заказали увидеть результат, то мы его обязательно увидим. Это - странный способ работы, но зато он работает всегда, а не «иногда». 
